/**
 * Queue Manager for Jetstream Events
 * 
 * Manages batched writes to Supabase with reliability patterns
 */

import { supabase } from '../supabase.ts';

const RETRY_ATTEMPTS = 3;

// In-memory queues
export const queues = {
  users: [] as any[],
  posts: [] as any[],
  likes: [] as any[],
  reposts: [] as any[],
  blocks: [] as any[],
  lists: [] as any[],
  listItems: [] as any[],
  threads: [] as any[],
  mentions: [] as any[],
  hashtags: [] as any[],
  links: [] as any[],
  media: [] as any[],
  activityPatterns: [] as any[],
  feedGenerators: [] as any[],
  threadgates: [] as any[],
  starterPacks: [] as any[],
  labelerServices: [] as any[],
  deadLetters: [] as any[],
};

async function upsertWithRetry(table: string, rows: any[], onConflict: string, attempts = RETRY_ATTEMPTS) {
  for (let i = 0; i < attempts; i++) {
    try {
      const { error } = await supabase.from(table).upsert(rows, { onConflict });
      if (error) throw error;
      return;
    } catch (e: any) {
      if (i === attempts - 1) {
        console.error(`Failed to upsert to ${table} after ${attempts} attempts:`, e);
        queues.deadLetters.push(...rows.map(r => ({
          table_name: table,
          data: r,
          error_message: e.message,
          created_at: new Date().toISOString()
        })));
      } else {
        await new Promise(r => setTimeout(r, 1000 * (i + 1)));
      }
    }
  }
}

async function insertWithRetry(table: string, rows: any[], attempts = RETRY_ATTEMPTS) {
  for (let i = 0; i < attempts; i++) {
    try {
      const { error } = await supabase.from(table).insert(rows);
      if (error) throw error;
      return;
    } catch (e: any) {
      if (i === attempts - 1) {
        console.error(`Failed to insert into ${table} after ${attempts} attempts:`, e);
        queues.deadLetters.push(...rows.map(r => ({
          table_name: table,
          data: r,
          error_message: e.message,
          created_at: new Date().toISOString()
        })) );
      } else {
        await new Promise(r => setTimeout(r, 1000 * (i + 1)));
      }
    }
  }
}


export async function flushUsers() {
  if (queues.users.length === 0) return;
  const raw = queues.users.splice(0);
  const byDid = new Map<string, any>();
  for (const u of raw) byDid.set(u.did, u);
  const batch = Array.from(byDid.values());
  await upsertWithRetry('bluesky_users', batch, 'did');
}

export async function flushPosts() {
  if (queues.posts.length === 0) return;
  const raw = queues.posts.splice(0);
  const byUri = new Map<string, any>();
  for (const p of raw) {
    if (!p.uri) continue;
    byUri.set(p.uri, {
      uri: p.uri,
      cid: p.cid,
      author_did: p.author_did,
      text: p.text ?? null,
      reply_parent: p.reply_parent ?? null,
      reply_root: p.reply_root ?? null,
      embed_type: p.embed_type ?? null,
      like_count: p.like_count ?? 0,
      repost_count: p.repost_count ?? 0,
      reply_count: p.reply_count ?? 0,
      quote_count: p.quote_count ?? 0,
      created_at: p.created_at || new Date().toISOString(),
      indexed_at: p.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_posts', batch, 'uri');
}


export async function flushLikes() {
  if (queues.likes.length === 0) return;
  const raw = queues.likes.splice(0);
  const byUri = new Map<string, any>();
  for (const l of raw) {
    if (!l.uri) continue;
    byUri.set(l.uri, {
      uri: l.uri,
      author_did: l.author_did,
      subject_uri: l.subject_uri,
      subject_cid: l.subject_cid,
      created_at: l.created_at || new Date().toISOString(),
      indexed_at: l.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_likes', batch, 'uri');
}


export async function flushReposts() {
  if (queues.reposts.length === 0) return;
  const raw = queues.reposts.splice(0);
  const byUri = new Map<string, any>();
  for (const r of raw) {
    if (!r.uri) continue;
    byUri.set(r.uri, {
      uri: r.uri,
      author_did: r.author_did,
      subject_uri: r.subject_uri,
      subject_cid: r.subject_cid,
      created_at: r.created_at || new Date().toISOString(),
      indexed_at: r.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_reposts', batch, 'uri');
}


export async function flushBlocks() {
  if (queues.blocks.length === 0) return;
  const raw = queues.blocks.splice(0);
  const byPair = new Map<string, any>();
  for (const b of raw) {
    const blocker = b.blocker_did || b.author_did;
    const blocked = b.blocked_did || b.subject_did;
    if (!blocker || !blocked) continue;
    const k = blocker + '|' + blocked;
    byPair.set(k, {
      uri: b.uri,
      blocker_did: blocker,
      blocked_did: blocked,
      created_at: b.created_at || new Date().toISOString(),
      indexed_at: b.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byPair.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_blocks', batch, 'blocker_did,blocked_did');
}


export async function flushLists() {
  if (queues.lists.length === 0) return;
  const raw = queues.lists.splice(0);
  const byUri = new Map<string, any>();
  for (const l of raw) {
    if (!l.uri) continue;
    byUri.set(l.uri, {
      uri: l.uri,
      creator_did: l.creator_did || l.author_did,
      name: l.name ?? null,
      purpose: l.purpose ?? null,
      description: l.description ?? null,
      avatar: l.avatar ?? null,
      member_count: l.member_count ?? 0,
      created_at: l.created_at || new Date().toISOString(),
      indexed_at: l.indexed_at || new Date().toISOString(),
      updated_at: l.updated_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_lists', batch, 'uri');
}


export async function flushListItems() {
  if (queues.listItems.length === 0) return;
  const raw = queues.listItems.splice(0);
  let existing = new Set<string>();
const uris = Array.from(new Set(raw.map(r => r.list_uri).filter(Boolean)));
if (uris.length > 0) {
  const chunkSize = 500;
  for (let i = 0; i < uris.length; i += chunkSize) {
    const slice = uris.slice(i, i + chunkSize);
    const { data, error } = await supabase
      .from('bluesky_lists')
      .select('uri')
      .in('uri', slice);
    if (!error && data) {
      for (const d of data) existing.add(d.uri);
    }
  }
}
const filtered = raw.filter(r => existing.has(r.list_uri));
  const byKey = new Map<string, any>();
for (const li of filtered) {
  if (!li.list_uri || !li.subject_did) continue;
  const k = `${li.list_uri}|${li.subject_did}`;
  byKey.set(k, {
    uri: li.uri ?? null,
    list_uri: li.list_uri,
    subject_did: li.subject_did,
    created_at: li.created_at || new Date().toISOString(),
    indexed_at: li.indexed_at || new Date().toISOString(),
  });
}
const batch = Array.from(byKey.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_list_items', batch, 'list_uri,subject_did');
}

export async function flushThreads() {
  if (queues.threads.length === 0) return;
  const raw = queues.threads.splice(0);
  const byPost = new Map<string, any>();
  for (const t of raw) {
    const post_uri = t.post_uri || t.reply_uri;
    if (!post_uri) continue;
    byPost.set(post_uri, {
      root_uri: t.root_uri ?? null,
      post_uri,
      parent_uri: t.parent_uri ?? null,
      author_did: t.author_did,
      created_at: t.created_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byPost.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_threads', batch, 'post_uri');
}


export async function flushMentions() {
  if (queues.mentions.length === 0) return;
  const batch = queues.mentions.splice(0);
  await insertWithRetry('bluesky_mentions', batch);
}


export async function flushHashtags() {
  if (queues.hashtags.length === 0) return;
  const raw = queues.hashtags.splice(0);
  const batch = raw.map(h => ({
    post_uri: h.post_uri,
    author_did: h.author_did,
    hashtag: h.hashtag,
    normalized_tag: h.normalized_tag,
    position: h.position ?? null,
    created_at: h.created_at || new Date().toISOString(),
  }));
  await insertWithRetry('bluesky_hashtags', batch);
}


export async function flushLinks() {
  if (queues.links.length === 0) return;
  const batch = queues.links.splice(0);
  await insertWithRetry('bluesky_links', batch);
}


export async function flushMedia() {
  if (queues.media.length === 0) return;
  const raw = queues.media.splice(0);
  const batch = raw.map(m => ({
    post_uri: m.post_uri,
    author_did: m.author_did,
    media_type: m.media_type,
    media_url: m.media_url ?? null,
    alt_text: m.alt_text ?? null,
    mime_type: m.mime_type ?? null,
    size_bytes: m.size_bytes ?? null,
    dimensions: m.dimensions ?? null,
    metadata: m.metadata ?? null,
    created_at: m.created_at || new Date().toISOString(),
  }));
  await insertWithRetry('bluesky_media', batch);
}


export async function flushActivityPatterns() {
  if (queues.activityPatterns.length === 0) return;
  const raw = queues.activityPatterns.splice(0);
  const byKey = new Map<string, any>();
  for (const r of raw) {
    const k = `${r.author_did}|${r.hour_of_day}|${r.day_of_week}`;
    const prev = byKey.get(k) || { ...r, post_count: 0 };
    prev.post_count = (prev.post_count || 0) + (r.post_count || 0 || 1);
    byKey.set(k, prev);
  }
  const batch = Array.from(byKey.values());
  await upsertWithRetry('bluesky_activity_patterns', batch.map(({created_at, ...r}: any) => r), 'author_did,hour_of_day,day_of_week');
}


export async function flushFeedGenerators() {
  if (queues.feedGenerators.length === 0) return;
  const raw = queues.feedGenerators.splice(0);
  const byUri = new Map<string, any>();
  for (const g of raw) {
    if (!g.uri) continue;
    byUri.set(g.uri, {
      uri: g.uri,
      author_did: g.author_did,
      display_name: g.display_name ?? null,
      description: g.description ?? null,
      created_at: g.created_at || new Date().toISOString(),
      indexed_at: g.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_feed_generators', batch, 'uri');
}


export async function flushThreadgates() {
  if (queues.threadgates.length === 0) return;
  const raw = queues.threadgates.splice(0);
  const batch = raw.map(tg => ({
    post_uri: tg.post_uri || tg.uri,
    owner_did: tg.owner_did || tg.author_did,
    allow: tg.allow ?? null,
    created_at: tg.created_at || new Date().toISOString(),
    indexed_at: tg.indexed_at || new Date().toISOString(),
  }));
  await upsertWithRetry('bluesky_threadgates', batch, 'post_uri');
}


export async function flushStarterPacks() {
  if (queues.starterPacks.length === 0) return;
  const raw = queues.starterPacks.splice(0);
  const byUri = new Map<string, any>();
  for (const sp of raw) {
    if (!sp.uri) continue;
    byUri.set(sp.uri, {
      uri: sp.uri,
      author_did: sp.author_did,
      name: sp.name ?? null,
      description: sp.description ?? null,
      created_at: sp.created_at || new Date().toISOString(),
      indexed_at: sp.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_starterpacks', batch, 'uri');
}


export async function flushLabelerServices() {
  if (queues.labelerServices.length === 0) return;
  const raw = queues.labelerServices.splice(0);
  const byUri = new Map<string, any>();
  for (const lb of raw) {
    if (!lb.uri) continue;
    byUri.set(lb.uri, {
      uri: lb.uri,
      author_did: lb.author_did,
      created_at: lb.created_at || new Date().toISOString(),
      indexed_at: lb.indexed_at || new Date().toISOString(),
    });
  }
  const batch = Array.from(byUri.values());
  if (batch.length === 0) return;
  await upsertWithRetry('bluesky_labeler_services', batch, 'uri');
}


export async function flushDeadLetters() {
  if (queues.deadLetters.length === 0) return;
  const batch = queues.deadLetters.splice(0);
  try {
    await supabase.from('bluesky_dead_letters').insert(batch);
  } catch (e) {
    console.error('Failed to save dead letters:', e);
  }
}

export async function flushAll() {
  // Order matters due to FKs: users -> lists -> list_items; posts early for enrichments
  await flushUsers();
  await flushLists();
  await flushPosts();
  await flushListItems();
  await flushBlocks();
  await flushLikes();
  await flushReposts();
  await flushThreads();
  await flushMentions();
  await flushHashtags();
  await flushLinks();
  await flushMedia();
  await flushActivityPatterns();
  await flushFeedGenerators();
  await flushThreadgates();
  await flushStarterPacks();
  await flushLabelerServices();
  await flushDeadLetters();
}
