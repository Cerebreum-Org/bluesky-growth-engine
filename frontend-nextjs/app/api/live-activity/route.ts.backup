import { NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';

export const revalidate = 1; // Cache for 1 second
export async function GET() {
  try {
    const now = new Date().toISOString();

    // Get counts
    const countsPromises = await Promise.all([
      supabase.from('bluesky_users').select('*', { count: 'exact', head: true }),
      supabase.from('bluesky_posts').select('*', { count: 'exact', head: true }),
      supabase.from('bluesky_likes').select('*', { count: 'exact', head: true }),
      supabase.from('bluesky_reposts').select('*', { count: 'exact', head: true }),
    ]);

    const totalUsers = countsPromises[0].count || 0;
    const totalPosts = countsPromises[1].count || 0;
    const totalLikes = countsPromises[2].count || 0;
    const totalReposts = countsPromises[3].count || 0;

    // Get recent activities - filter out future timestamps
    const [usersRes, postsRes, likesRes, repostsRes] = await Promise.all([
      supabase
        .from('bluesky_users')
        .select('did, handle, display_name, followers_count, updated_at')
        .lte('updated_at', now)
        .order('updated_at', { ascending: false })
        .limit(10),
      
      supabase
        .from('bluesky_posts')
        .select('uri, text, author_did, created_at')
        .lte('created_at', now)
        .order('created_at', { ascending: false })
        .limit(5),
      
      supabase
        .from('bluesky_likes')
        .select('uri, author_did, subject_uri, created_at')
        .lte('created_at', now)
        .order('created_at', { ascending: false })
        .limit(5),
      
      supabase
        .from('bluesky_reposts')
        .select('uri, author_did, subject_uri, created_at')
        .lte('created_at', now)
        .order('created_at', { ascending: false })
        .limit(5),
    ]);

    // Get author handles
    const authorDids = new Set<string>();
    [postsRes.data, likesRes.data, repostsRes.data].forEach(items => {
      items?.forEach(item => authorDids.add(item.author_did));
    });

    const { data: authors } = await supabase
      .from('bluesky_users')
      .select('did, handle, display_name')
      .in('did', Array.from(authorDids));

    const authorMap = new Map(authors?.map(a => [a.did, a]) || []);

    // Build activities
    const activities: any[] = [];

    (usersRes.data || []).forEach(user => {
      activities.push({
        type: 'user',
        timestamp: user.updated_at,
        data: {
          handle: user.handle,
          display_name: user.display_name,
          followers_count: user.followers_count,
        }
      });
    });

    (postsRes.data || []).forEach(post => {
      const author = authorMap.get(post.author_did);
      activities.push({
        type: 'post',
        timestamp: post.created_at,
        data: {
          handle: author?.handle,
          display_name: author?.display_name,
          text: post.text?.substring(0, 100) || '',
        }
      });
    });

    (likesRes.data || []).forEach(like => {
      const author = authorMap.get(like.author_did);
      activities.push({
        type: 'like',
        timestamp: like.created_at,
        data: {
          handle: author?.handle,
          display_name: author?.display_name,
        }
      });
    });

    (repostsRes.data || []).forEach(repost => {
      const author = authorMap.get(repost.author_did);
      activities.push({
        type: 'repost',
        timestamp: repost.created_at,
        data: {
          handle: author?.handle,
          display_name: author?.display_name,
        }
      });
    });

    activities.sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );

    return NextResponse.json({
      counts: {
        users: totalUsers,
        posts: totalPosts,
        likes: totalLikes,
        reposts: totalReposts,
      },
      activities: activities.slice(0, 15),
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Error fetching live activity:', error);
    return NextResponse.json({ error: 'Failed to fetch activity' }, { status: 500 });
  }
}
